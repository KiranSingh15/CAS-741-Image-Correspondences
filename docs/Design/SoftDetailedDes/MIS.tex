\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2025-03-19 & 1.0 & Initial Release\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/KiranSingh15/CAS-741-Image-Correspondences/blob/main/docs/SRS/SRS.pdf}.

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by the \progname software. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
string & str & a sequence of characters\\
boolean & $\mathbb{F}_{2}$ & a number in the binary field, where all elements are \{0,1\}\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{9}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& Input Format Module \\
& Specification Parameters \\
& Output Format Module \\
& Output Verification Module \\
& Control Module \\
& Image Smoothing Module \\
& Keypoint Detection Module \\
& Feature Descriptor Module \\
& Feature Matching Module \\
\midrule

\multirow{5}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& Image Data Structure Module \\
& Image Plot Module \\
& Feature Match Data Module \\
& Dataframe Structure Module \\
& ORB Data Structure Module \\
\bottomrule
 
\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Input Format Module} \label{mIF}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

config

\subsection{Uses}
\begin{itemize}
\item specParams (Section~\ref{mSP})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{3.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
get\_head\_directory & - & head\_path as string & noHeadFound \\
\hline
get\_active\_functions & - & tuple (user-methods) & - \\
\hline
get\_chosen\_parameters & - & tuple (user-params) & - \\
\hline
get\_img\_names & head\_path as str & img\_names as $str^{n}$ & - \\
\hline
check\_limits & tuple (user-params) & - & 
badKernelSize, \newline badStdDeviation, \newline
badFASTThrehold, \newline badBinSize, \newline
badPatchSize\\
\hline
\end{tabular}


\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item kernel\_sz $ \in \mathbb{Z}$
  \item std\_deviation $ \in \mathbb{R}$
  \item FAST\_threshold $ \in \mathbb{Z}$
  \item bin\_sz $ \in \mathbb{Z}$
  \item patch\_sz $ \in \mathbb{Z}$
  \item mthd\_img\_smoothing $ \in \mathbb{Z}$
  \item mthd\_kp\_detection $ \in \mathbb{Z}$
  \item mthd\_kp\_description $ \in \mathbb{Z}$
  \item mthd\_ft\_match $ \in \mathbb{Z}$
\end{itemize}

tuple of methods and parameters goes here.\\
set the state as the defaults, \\
then set the state as the user defined methods, if available


\subsubsection{Environment Variables}
\begin{itemize}
  \item head\_path as str
\end{itemize}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}
\noindent get\_head\_directory():
\begin{itemize}
  \item output: head\_path = Path(os.getcwd()) where head\_path is a string
\end{itemize}


\noindent get\_active\_functions():
\begin{itemize}
  \item output: [mthd\_img\_smoothing, mthd\_kp\_detection, 
  mthd\_kp\_description, mthd\_ft\_match $\in \mathbb{Z}$] 
\end{itemize}


\noindent get\_chosen\_parameters():
\begin{itemize}
  \item output: [kernel\_sz, bin\_sz, patch\_sz, FAST\_threshold $\in \mathbb{Z}$,  
  std\_deviation $ \in \mathbb{R}$]
\end{itemize}


\noindent get\_img\_names(head\_path as str): \newline \newline
img\_path = Path(head\_path + "Raw\_Images") \newline
img\_dir = Path(img\_path) \newline
input\_img = [(file.stem, file.suffix, file.name) 
for file in img\_dir.iterdir() if file.is\_file()] \newline
num\_images = len(input\_img)
\begin{itemize}
\item output: input\_img $\in str^{n}$, num\_images $\in \mathbb{N}$
\item exception: none 
\end{itemize}


\noindent check\_limits():
\begin{itemize}
  \item output: none
  \item exception: exc:=
  \noindent \begin{longtable*}[l]{l l} 
    $\neg (kernel\_sz < 1)$ & $\Rightarrow$ badKernelSize\\
    $\neg (kernel\_sz > 15)$ & $\Rightarrow$ badKernelSize\\
    $\neg (kernel\_sz \; \% \; 2 \neq 0)$ & $\Rightarrow$ badKernelSize\\
    $\neg (0 < std\_deviation < 10)$ & $\Rightarrow$ badStdDeviation\\
    $\neg (2 \leq FAST\_threshold \leq 255)$ & $\Rightarrow$ badFASTThreshold\\
    $\neg (1 \leq bin\_sz \leq 2048)$ & $\Rightarrow$ badBinSize\\
    $\neg (5 \leq patch\_sz \leq 100)$ & $\Rightarrow$ badPatchSize\\
    \end{longtable*}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Specification Parameters Module} \label{mSP}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
specParams (Section~\ref{mIF})

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item $kernel\_sz: = 5$
  \item $std\_deviation: = 1$ 
  \item $FAST\_threshold: = 15$ 
  \item $bin\_sz: = 2000$ 
  \item $patch\_sz: = 31$ 
  \item $mthd\_img\_smoothing: = 1$
  \item $mthd\_kp\_detection: = 1$ 
  \item $mthd\_kp\_description: = 1$
  \item $mthd\_ft\_match: = 1$
\end{itemize}
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{3.5cm} p{4cm} p{3.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
get\_default\_parameters & - & 
$kernel\_sz: \mathbb{Z}$ \newline 
$std\_deviation: \mathbb{R}$ \newline 
$FAST\_threshold: \mathbb{Z}$ \newline 
$bin\_sz: \mathbb{Z}$ \newline 
$patch\_sz: \mathbb{Z}$ 
& - \\
\hline
get\_default\_methods & - & 
$mthd\_img\_smoothing:\mathbb{Z}$ \newline 
$mthd\_kp\_detection:\mathbb{Z}$ \newline 
$mthd\_kp\_description:\mathbb{Z}$ \newline 
$mthd\_ft\_match:\mathbb{Z}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

$kernel\_sz: \mathbb{Z}$ \\
$std\_deviation: \mathbb{R}$ \\
$FAST\_threshold: \mathbb{R}$ \\
$bin\_sz: \mathbb{Z}$ \\
$patch\_sz: \mathbb{Z}$ \\
$mthd\_img\_smoothing: \mathbb{Z}$ \\
$mthd\_kp\_detection: \mathbb{Z}$ \\
$mthd\_kp\_description: \mathbb{Z}$ \\
$mthd\_ft\_match: \mathbb{Z}$ \\

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}
\noindent get\_default\_parameters():
\begin{itemize}
\item output:
  \begin{itemize}
  \item $kernel\_sz: \mathbb{Z}$
  \item $std\_deviation: \mathbb{R}$ 
  \item $FAST\_threshold: \mathbb{Z}$ 
  \item $bin\_sz: \mathbb{Z}$ 
  \item $patch\_sz: \mathbb{Z}$ 
  \end{itemize}
  \item exception: none  
\end{itemize}

\noindent get\_default\_methods():
\begin{itemize}
\item output:
  \begin{itemize}
    \item $mthd\_img\_smoothing: \mathbb{Z}$
    \item $mthd\_kp\_detection: \mathbb{Z}$ 
    \item $mthd\_kp\_description: \mathbb{Z}$
    \item $mthd\_ft\_match: \mathbb{Z}$
  \end{itemize}
  \item exception: none 
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Output Format Module} \label{mOF}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

formatOutput

\subsection{Uses}
\begin{itemize}
\item matchStruct (Section~\ref{mC})
\item dataframeStruct (Section~\ref{mDF})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
Not applicable.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
- & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item 
\end{itemize}

\subsubsection{Environment Variables}



\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}


\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}


\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Output Verification Module} \label{mOV}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

verifyOutput

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
%%%%%%%%%% 
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Control Module} \label{mC}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

main

\subsection{Uses}
\begin{itemize}
  \item matchFeatures (Section~\ref{mFM})
  \item plotImage (Section~\ref{mIP})
  \item formatOutput (Section~\ref{mOF})
  \item verifyOutput (Section~\ref{mOV})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item kernel\_sz $ \in \mathbb{Z}$
  \item std\_deviation $ \in \mathbb{R}$
  \item FAST\_threshold $ \in \mathbb{Z}$
  \item bin\_sz $ \in \mathbb{Z}$
  \item patch\_sz $ \in \mathbb{Z}$
  \item mthd\_img\_smoothing $ \in \mathbb{Z}$
  \item mthd\_kp\_detection $ \in \mathbb{Z}$
  \item mthd\_kp\_description $ \in \mathbb{Z}$
  \item mthd\_ft\_match $ \in \mathbb{Z}$
  \item img\_obj\_1, img\_obj\_2 $\in \mathbb{Z}^{h \times w}$ 
\end{itemize}

% do we need to make these directories here? I dont think so


\subsubsection{Environment Variables}
\begin{itemize}
  \item head\_dir as \textbf{str}
  \item path\_input\_img as \textbf{str} 
  \item path\_keypoints as \textbf{str}
  \item path\_descriptors as \textbf{str}
  \item path\_feature\_matches as \textbf{str}
\end{itemize}


\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}
\noindent main():
\begin{itemize}
\item transition: Modify the state of the Specification Parameters Module and the 
environment variables for the Image Plot Module and Output Format Module.
\end{itemize}
[head\_dir as str] = get\_head\_directory() \newline \newline
[mthd\_img\_smoothing $\in \mathbb{Z}$, mthd\_kp\_detection $\in \mathbb{Z}$, 
mthd\_kp\_descriptors $\in \mathbb{Z}$, mthd\_ft\_matching $\in \mathbb{Z}$] 
= get\_chosen\_methods() \newline \newline
[kern\_sz $\in \mathbb{Z}$, std\_deviation $\in \mathbb{R}$, 
FAST\_threshold $\in \mathbb{Z}$, bin\_sz $\in \mathbb{Z}$, 
patch\_sz $\in \mathbb{Z}$] = get\_chosen\_parameters() \newline \newline
\#\# \textit{For each image, i}\newline
\# \textit{Smooth the image as a preprocessing step to keypoint detection} \newline
img\_obj\_1 = smooth\_image(img\_obj\_1$ \in \mathbb{Z}^{h \times w}$, kernel\_sz$ \in \mathbb{Z}$, 
std\_deviation$ \in \mathbb{R}$) \newline \newline
\# \textit{Identify the keypoints. Note that if the methods for keypoint detection and 
descriptors are both == 1, then ORB is the selected method, and the keypoint and descriptor 
modules should use the same ORB object, which likely will come from the OpenCV library}\newline
\newline 
\# \textit{Assign descriptors to keypoints} \newline \newline
\# \textit{export keypoints to csv} \newline 
\# \textit{export descriptors to csv} \newline\newline
\# \textit{generate and save image with keypoints} \newline 
\# \textit{generate and save image with scaled keypoints} \newline
\#\# \newline \newline
\# \textit{Compare features between differing images} \newline \newline
\# \textit{verify that the match structure conforms to the conditions in the
Output Verification Module} \newline \newline 
\# \textit{export matche tuples to csv} \newline 
\# \textit{generate and save images with corresponding matches} \newline



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Image Smoothing Module} \label{mIS}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}
\subsection{Module}

smoothImage

\subsection{Uses}
\begin{itemize}
  \item config (Section~\ref{mC})
  \item imageStruct (Section~\ref{mIDS})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
smooth\_image & 
noisy\_img: $\mathbb{Z}^{H \times W}$, \newline 
kernel\_sz: $\mathbb{Z}$ \newline
std\_deviation: $\mathbb{R}$
 & smoothed\_img: $\mathbb{Z}^{H \times W}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item smoothed\_img: $\mathbb{Z}^{H \times W}$
\end{itemize}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
  \begin{itemize}
  \item Exceptions on input limits are handled in specParams module.
  \end{itemize}

\subsubsection{Access Routine Semantics}

\noindent smooth\_image(c $\in \mathbb{Z}^{H \times W}$, 
kernel\_sz $\in \mathbb{Z}$, std\_deviation $\in \mathbb{R}$):\newline \newline
\# \textit{if method == 1, perform Gaussian Blur with OpenCV }\newline
img\_blur = GaussianBlur(noisy\_img, kernel\_sz, std\_deviation)\newline
\begin{itemize}
\item output: img\_blur $\in \mathbb{Z}^{h \times w}$
\end{itemize}

\begin{itemize}
\item exception: None
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Keypoint Detection Module} \label{mKD}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

detectKeypoints

\subsection{Uses}
\begin{itemize}
  \item config (Section~\ref{mIF})
  \item smoothImage (Section~\ref{mIS}) % may be removed since image smoothing is optional
  \item imageStruct (Section~\ref{mIDS}) % to be merged as OpenCV library
  \item orbStruct (Section~\ref{mORB}) % to be merged as OpenCV library
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4.5cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
load\_img & sel\_read\_path as \textbf{str} & img $\in \mathbb{Z}^{h \times w}$ & - \\
\hline
detectKeypoints & mthd\_kp\_detection $\in \mathbb{Z}$,\newline
img $\in \mathbb{Z}^{h \times w}$, \newline 
\text{bin\_sz}$\in \mathbb{Z}$, \newline 
\text{patch\_sz} $\in \mathbb{Z}$, \newline 
\text{FAST\_threshold} $\in \mathbb{Z}$ 
& orb\_object as \textbf{TBD}, \newline 
keypoints as \textbf{keypoint tuple} & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item orb\_object as \textbf{TBD}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item sel\_read\_path as \textbf{str}
\end{itemize}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent load\_img(sel\_read\_path as \textbf{str}):\\
read\_path = sel\_read\_path

img = cv.imread(sel\_read\_path)

\begin{itemize}
\item output: img $\in \mathbb{Z}^{h \times w}$
\item exception: None.
\end{itemize}

\noindent detectKeypoints(mthd\_kp\_detection $\in \mathbb{Z}$, 
img $\in \mathbb{Z}^{h \times w}, \text{bin\_sz}\in \mathbb{Z}, \text{patch\_sz}\in 
\mathbb{Z}, \text{FAST\_threshold} \in \mathbb{Z}$):

\begin{itemize}
  \item transition: Generate instance of of the detector object
\end{itemize}

if mthd\_kp\_detection $== 1$ \newline

orb\_object = ORB.create($\text{bin\_sz}\in \mathbb{Z}, \text{patch\_sz}\in 
\mathbb{Z}, \text{FAST\_threshold} \in \mathbb{Z}$) \newline

orb\_object.detect(img $\in \mathbb{Z}^{h \times w}$)
\begin{itemize}
  \item output: Returns orb\_object and the set of keypoints \(K = \{ (x_i, y_i, s_i, \theta_i, r_i) 
  \mid i \in \mathbb{N} \} \), where:
  \begin{itemize}
      \item \( (x_i, y_i) \in \mathbb{R}^2 \) (spatial coordinates)
      \item \( s_i \in \mathbb{R}^+ \) (scale)
      \item \( \theta_i \in [0, 2\pi] \) (orientation)
      \item \( r_i \in \mathbb{R} \) (response strength)
  \end{itemize}
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Feature Descriptor Module} \label{mFD}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

assignDescriptors

\subsection{Uses}
\begin{itemize}
  \item detectKeypoints (Section~\ref{mKD})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{5cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
compute\_descriptors & mthd\_kp\_descriptors $\in \mathbb{Z}$ \newline
img $\in \mathbb{Z}^{m\times n}$ \newline 
keypoints as \textbf{keypoint tuple}& desc $\in \mathbb{F}_{2}^{256}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item orb\_object as \textbf{TBD}
\end{itemize}

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

ORB object is instatiated in the Keypoint Detector Module.

\subsubsection{Access Routine Semantics}

\noindent compute\_descriptors(orb\_obj as \textbf{TBD}, img $\in 
\mathbb{Z}^{h \times w}$, keypoints as keypoint ADT):\\
desc = orb\_object.compute(img, keypoints)
\begin{itemize}
\item output: desc $\in \mathbb{F}_{2}^{256}$
\item exception: None 
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Feature Matching Module} \label{mFM}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

matchFeatures

\subsection{Uses}
\begin{itemize}
  \item assignDescriptors (Section~\ref{mFD})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{4cm} p{3.5cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
create\_BF\_matcher & mthd\_ft\_match $\in \mathbb{Z}$ 
& matcher\_object as \textbf{TBD}& - \\
\hline
match\_features & mthd\_ft\_match $\in \mathbb{Z}$, \newline
bf\_matcher\_object as \textbf{(TBD)}, \newline
desc1 and desc2 as $\in \mathbb{F}_{2}^{n\times 256}$ 
& $M = \{ m_i \mid m_i = (d_{1i}, d_{2i}, 
dist_{Hamming})\}$ & - \\
\hline
sort\_matches & mthd\_ft\_match $\in \mathbb{Z}$, \newline 
$M = \{ m_i \mid m_i = (d_{1i}, d_{2i}, dist_{Hamming})\}$ & 
matches $\in M = \{m_i | m_i = (d_{1i}, d_{2i}, dist_{Hamming})\}$ 
& - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

Exception handling on user-selected methods and parameters are handled in the Parameter 
Specification Module.

\subsubsection{Access Routine Semantics}

create\_BF\_matcher(mthd\_ft\_match $\in \mathbb{Z}$):\\ \\
if mthd\_ft\_match $== 1$
\begin{itemize}
  \item output: bf\_matcher\_object = cv.BFMatcher(cv.NORM\_HAMMING, crossCheck=True) 
  \# Python syntax
  \item exception: None
\end{itemize} 
match\_features(mthd\_ft\_match $\in \mathbb{Z}$, bf\_matcher\_object as \textbf{(TBD)},  
$desc1$ and $desc2$ as $\in \mathbb{F}_{2}^{n\times 256}$:\\
if mthd\_ft\_match $== 1$:
\begin{itemize}
  \item \textbf{output:} M = bf\_matcher\_object.match(desc1, desc2), such that \newline
  matches $M = \{ m_i \mid m_i = (d_{1i}, d_{2i}, dist_{Hamming})\}$, where $d_{1i} 
  \in desc1, d_{2i} \in desc2, \; dist_{Hamming} \in \mathbb{N}$, 
  where $dist_{Hamming}$ is the match distance.
  \item \textbf{exception:} None
\end{itemize}
sort\_matches(mthd\_ft\_match $\in \mathbb{Z}$, $M = \{ m_i \mid m_i = (d_{1i}, d_{2i}, 
dist_{Hamming})\}$, where $d_{1i} 
  \in desc1, d_{2i} \in desc2, \; dist_{Hamming} \in \mathbb{N}$): \newline
if mthd\_ft\_match $== 1$: \newline
matches = bf\_matcher\_object.sorted(M) 
\begin{itemize}
  \item \textbf{output:} matches $\in M = \{m_i | m_i = (d_{1i}, d_{2i}, dist_{Hamming})\}$
  \item \textbf{exception:} None
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Image Data Structure Module} \label{mIDS}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

imageStruct

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
cv.imread & sel\_read\_path as \textbf{str} & 
img $\in \mathbb{Z}^{h \times w}$ & inValidImgPath \\
\hline
cv.imwrite & sel\_save\_path as \textbf{str}, \newline 
out\_img $\in \mathbb{Z}^{h \times w}$ & 
img\_png \textbf{as .png} & inValidImgPath \\
\hline
cv.drawKeypoints & img\_in, overlayImage as $\in \mathbb{Z}^{h \times w}$, \newline
keypoints as \textbf{keypoint tuple}, \newline
colour $\in \mathbb{Z}^{3}$, \newline 
flags $\in \mathbb{Z}$ & img\_kp $\in \mathbb{Z}^{h \times w}$ & - \\
\hline
cv.drawMatches & img1\_in, img2\_in, overlay\_image as $\in 
\mathbb{Z}^{h \times w}$, \newline
kp1, kp2 as \textbf{keypoint tuple}, \newline
matches as \textbf{match tuple}, \newline
flags $\in \mathbb{Z}$ 
& img\_matches $\in \mathbb{Z}^{h \times w}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item img\_1\_name = as \textbf{str}
\item img\_2\_name = as \textbf{str}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item read\_path as \textbf{str}
  \item save\_path as \textbf{str}
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item ORB objects are initialized prior to use
  \item BFMatcher objects are initialized prior to use
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent cv.imread(sel\_read\_path as \textbf{str}):
\begin{itemize}
\item transition: read\_path = sel\_read\_path
\item output: img $\in \mathbb{Z}^{h \times w}$
\item exception: if no image identified, flag as inValidImgPath 
\end{itemize}

\noindent cv.imwrite(sel\_save\_path as \textbf{str}, out\_img 
$\in \mathbb{Z}^{h \times w}$):
\begin{itemize}
\item transition: save\_path = sel\_save\_path
\item output: img\_png \textbf{as .png}
\item exception: if path is undefined, flag as inValidImgPath 
\end{itemize}

\noindent cv.drawKeypoints(img\_in as $\in \mathbb{Z}^{h \times w}$, 
keypoints as \textbf{keypoint tuple}, overlayImage $\in \mathbb{Z}^{h \times w}$,
colour $\in \mathbb{Z}^{3}$, flags $\in \mathbb{Z}$):
\begin{itemize}
\item output: img\_kp $\in \mathbb{Z}^{3}$
\end{itemize}

\noindent cv.drawMatches(img1\_in as $\in \mathbb{Z}^{h \times w}$, 
kp1 as \textbf{keypoint tuple}, img2\_in as $\in \mathbb{Z}^{h \times w}$, 
kp2 as \textbf{keypoint tuple}, matches as \textbf{match tuple}, overlay\_image $\in \mathbb{Z}^{h \times w}$,
flags $\in \mathbb{Z}$):
\begin{itemize}
\item output: img\_matches $\in \mathbb{Z}^{h\times w}$
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Image Plot Module} \label{mIP}
\subsection{Module}
plotImage

\subsection{Uses}
\begin{itemize}
  \item imageStruct (Section~\ref{mIP})
\end{itemize}

\subsection{Syntax}
\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{5cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
gen\_kp\_img & img\_in, as $\in \mathbb{Z}^{h \times w}$, \newline
keypoints as \textbf{keypoint tuple}, \newline
flags $\in \mathbb{Z}$ & img\_kp $\in \mathbb{Z}^{h \times w}$ & - \\
\hline
gen\_matched\_features 
& img\_1, img\_2 $\in \mathbb{Z}^{h \times w}$, \newline
kp\_1, kp\_2 as \textbf{keypoint tuple} \newline
matches as \textbf{match tuple}, \newline 
max\_matches $\in \mathbb{N}$
& img\_matches $\in \mathbb{Z}^{h \times w}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

DrawMatchesFlag $\in \mathbb{Z}$

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
  \item save\_kp\_img has been initialized with keypoints
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent gen\_kp\_img(img\_in, $\in \mathbb{Z}^{h \times w}$, keypoints 
as \textbf{keypoint tuple}):\newline
img\_keypoints = cv.drawKeypoints(img\_in, keypoints, None, colour=(0, 255, 0), 
flags=0)
\begin{itemize}
  \item output: img\_keypoints $\in \mathbb{Z}^{h \times w}$
\end{itemize}


\noindent gen\_matched\_features(img\_1, img\_2 $\in \mathbb{Z}^{h \times w}$,
kp\_1, kp\_2 as \textbf{keypoint tuple}, matches as \textbf{match tuple}, 
max\_matches $\in \mathbb{N}$): \newline 
img\_matches = cv.drawMatches(img\_1, kp\_1, img\_2, kp\_2, matches[:max\_matches], 
None, flags=DrawMatchesFlag) 
\begin{itemize}
  \item output: img\_matches $\in \mathbb{Z}^{h \times w}$
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of ORB Data Structure Module} \label{mORB}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}
\subsection{Module}

orbStruct

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{6cm} p{4.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Exceptions} \\
\hline
GaussianBlur & $\text{img} \in \mathbb{Z}^{h \times w}, \newline 
\text{kernel\_sz} \in \mathbb{Z}, \newline 
\text{std\_deviation} \in \mathbb{R} $
& smooth\_img $\in \mathbb{Z}^{m\times n}$ & -\\
\hline
ORB.create & $\text{bin\_sz}\in \mathbb{Z}, \newline 
\text{patch\_sz}\in \mathbb{Z}, \newline 
\text{FAST\_threshold} \in \mathbb{Z}$ & orb\_object & None \\
\hline
orb\_object.detect & $\text{img} \in \mathbb{Z}^{h \times w}$ & $K$ (set of keypoints) & invalidImg \\
\hline
orb\_object.compute & $\text{img} \in \mathbb{Z}^{h \times w}$, \newline 
$K$ where $K$ is a set of keypoints & $D$ (set of descriptors) & invalidImg, invalidKeypoints \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
orb\_object $\in$ \textbf{TBD}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item The input image is a valid grayscale or color image.
    \item Keypoints are detected before computing descriptors.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GaussianBlur$(\text{img} \in \mathbb{Z}^{h \times w}, (\text{kernel\_sz} 
\in \mathbb{Z}, \text{kernel\_sz} \in \mathbb{Z}), \text{std\_deviation} \in \mathbb{R})$:
\begin{itemize}
    \item Output: $\text{img\_blur} \in \mathbb{Z}^{h \times w}$
    \item Exception: None. Exceptions are handled in Input Format Module.
\end{itemize}
\noindent ORB.create$(\text{bin\_sz} \in \mathbb{Z}, \text{patch\_sz} \in \mathbb{Z}, \text{FAST\_threshold} \in \mathbb{Z})$:
\begin{itemize}
    \item Output: Initializes orb\_object as \textbf{TBD}
    \item Exception: None. Exceptions are handled in Input Format Module.
\end{itemize}
\noindent orb\_object.detect$(\text{img} \in \mathbb{Z}^{h \times w})$:
\begin{itemize}
    \item Output: Returns the set of keypoints \( K = \{ (x_i, y_i, s_i, \theta_i, r_i) \mid i \in \mathbb{N} \} \), where:
    \begin{itemize}
        \item \( (x_i, y_i) \in \mathbb{R}^2 \) (spatial coordinates)
        \item \( s_i \in \mathbb{R}^+ \) (scale)
        \item \( \theta_i \in [0, 2\pi] \) (orientation)
        \item \( r_i \in \mathbb{R} \) (response strength)
    \end{itemize}
    \item Exception: invalidImage
\end{itemize}
\noindent orb\_object.compute$(\text{img}, K)$:
\begin{itemize}
    \item Output: Returns a set of binary descriptors 
    \( D = \{ d_i \mid d_i \in \mathbb{F}_2^{n\times 256}, i \in \mathbb{N} \} \).
    \item Exception:
    \begin{itemize}
      \item image not found $\Rightarrow$ invalidImg
      \item keypoints not found $\Rightarrow$ invalidKeypoints
    \end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Feature Match Data Module} \label{mFMD}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}
\subsection{Module}

matchStruct

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{5cm} p{3cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  BFMatcher & match\_method $\in \mathbb{Z}$, cross\_check\_flag $\in \mathbb{F}$ 
  & brute\_force\_object as \textbf{TBD}\newline 
  & None.\\
  \hline
  brute\_force\_object.\newline 
  match & brute\_force\_object as \textbf{TBD}, \newline
  $D_1, D_2 \in \mathbb{F}_{2}^{n\times 256}$ & 
  Returns a tuple of matches $M = \{ m_i \mid m_i = (d_{1i}, d_{2i}, dist_{Hamming})$, \newline
  such that $d_{1i} \in D_1, d_{2i} \in D_2, \; dist_{Hamming} \in \mathbb{N}$, 
  where $dist_{Hamming}$ is the match distance. & Raises an error if descriptors are 
  invalid or empty. \\
  \hline
  brute\_force\_object.\newline 
  sorted & $M$, as tuple of match objects, \newline
  key=lambda x: x.distance
  & Returns a sorted tuple of matches $M'$, where 
  $m'_i = (d_{1i}, d_{2i}, dist_{Hamming})$
  matches are sorted in ascending order of $dist_{Hamming}$. & Raises an 
  error if the match set is empty. \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize} 
  \item brute\_force\_object as \textbf{TBD}
\end{itemize}

\subsubsection{Environment Variables}
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}
\begin{itemize}
  \item the brute\_force\_object is initialized before matching is called 
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent cv.BFMatcher(match\_method $\in \mathbb{Z}$, cross\_check\_flag $\in \mathbb{F}$):
\begin{itemize}
\item output: Initializes brute\_force\_object  as \textbf{TBD}
\item exception: None. Exceptions are handled in Input Format Module.
\end{itemize}

\noindent brute\_force\_object.match($D_1, D_2 \in \mathbb{F}_{2}^{n \times 256}$):
\begin{itemize}
\item output: Returns matches, $ M = \{ m_i \mid i \in \mathbb{N} \} $ as a tuple, 
where each match \( m_i \) is defined as 
$m_i = (d_{1i}, d_{2i}, dist_{Hamming})$
with $d_{1i} \in D_1, d_{2i} \in D_2, \; dist_{Hamming} \in \mathbb{N}$, 
where $dist_{Hamming}$ represents the match distance.

\item exception: Raises an error if the descriptors are invalid or empty.
\end{itemize}

\noindent brute\_force\_object.sorted(M as \textbf{match tuple}, key=lambda x: x.distance): 
\begin{itemize} 
  \item output: Returns a sorted tuple of matches $M'$, where matches are sorted in 
  ascending order of distance, $dist_{Hamming}$. 
  \item exception: Raises an error if the match set is empty. 
\end{itemize}





\section{MIS of Dataframe Structure Module} \label{mDF} \wss{Use labels for
cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

dataframeStruct

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}
\wss{Extra information if required}
\end{document}